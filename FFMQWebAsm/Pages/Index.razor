@page "/"
@using Microsoft.AspNetCore.Components.Forms
@using System.IO;
@using System;
@using System.Web
@using System.Net.Http
@using System.Text;
@using FFMQLib;
@using Microsoft.JSInterop;
@using Microsoft.JSInterop.WebAssembly;
@using Blazorise.Components;
@using RomUtilities;
@using Microsoft.AspNetCore.Components
@inject IJSRuntime JS
@inject NavigationManager NavigationManager
@inject Blazored.LocalStorage.ISyncLocalStorageService localStorage
@inject HttpClient Http


<style>
    body {

        background: linear-gradient(rgba(27,42,81,1),rgba(85,109,171,1)) no-repeat center fixed;
        background-size: cover;
    }
</style>

<div class="@(sandboxMode ? "center-logo-sandbox" : "center-logo")">
    @if (sandboxMode)
    {
        <img height=@titleHeight src="logo/logosandbox_hebinx.gif" />
    }
    else
    {
        <img height=@titleHeight src="@titleLetters[0]" /><img height=@titleHeight src="@titleLetters[1]" /><img height=@titleHeight src="@titleLetters[2]" /><img height=@titleHeight src="@titleLetters[3]" /><img height=@titleHeight src="@titleLetters[4]" /><img height=@titleHeight src="@titleLetters[5]" /><img height=@titleHeight src="logo/mqlogo_.png" /><img height=@titleHeight src="@titleLetters[6]" /><img height=@titleHeight src="@titleLetters[7]" /><img height=@titleHeight src="@titleLetters[8]" /><img height=@titleHeight src="@titleLetters[9]" /><img height=@titleHeight src="@titleLetters[10]" />
    }
</div>
<h1 class="text-secondary text-center" style="font-size: 1em">A FFMQ Randomizer<br />@("v" + @FFMQLib.Metadata.Version + (@betaStatus ? "-beta" : "") + (@sandboxMode ? " Sandbox" : ""))</h1>


<div id="fileSection"><br /><br /></div>

<PresetsSection Name="Presets" SetPresetAction="@OnPresetAction" SetExportFile="@OnExportYaml"/>

<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">
        Generation       
    </div> 

    <Container Class="flagBox">
        <Container Class="flagColumn">
        @if(!romLoaded)
        {
            <Field class="romFlag">
                <FieldLabel TextColor="TextColor.Secondary" class="fw-bold">ROM</FieldLabel> 
                <FileEdit Filter=".sfc" AutoReset="false" Changed="@LoadFiles"></FileEdit>
                <FieldHelp>@romMessage</FieldHelp>
            </Field>
        }
        else
        {
            <Field class="romFlag">
                <FieldLabel TextColor="TextColor.Secondary" class="fw-bold">ROM</FieldLabel> 
                <Button Color="Color.Primary" Loading="@isGenerating" Clicked="@OnGenerate" Disabled="@isLoadingRom" class="romBtn">Generate</Button>
                <FieldHelp>@romMessage</FieldHelp>
            </Field>
        }

            <Fields class="dropFlag">
                <Field>
                    <FieldLabel TextColor="TextColor.Secondary" class="fw-bold">Seed</FieldLabel> 
                    <TextEdit Placeholder="Seed" Text="@showSeed" FocusOut="@SeedOnLoseFocus" KeyUp="@SeedOnKeyUp" TextChanged="@SeedOnChanged"/>
                    <FieldHelp>@seedMessage</FieldHelp>
                </Field>
                <Field>
                    <FieldLabel Visibility="Visibility.Invisible">None</FieldLabel>
                    <Button Color="Color.Primary" Clicked="@RollSeed" class="field-button romBtn">Roll Seed</Button>
                </Field>
            </Fields>
        </Container>
        <Container Class="flagColumn">
            <Fields class="dropFlag">
                <Field>
                    <FieldLabel TextColor="TextColor.Secondary" class="fw-bold">Flag String</FieldLabel> 
                    <TextEdit Placeholder="Flag string" Text="@flagString" FocusOut="@FlagsOnLoseFocus" KeyUp="@FlagsOnKeyUp" TextChanged="@FlagsOnChanged"/>
                    <FieldHelp>@flagsMessage</FieldHelp>
                </Field>
            </Fields>

        @if(romLoaded)
        {
            <a href="" @onclick="@UnloadRom" @onclick:preventDefault>Use a different ROM file</a>
        }
        </Container>
    </Container>
</Container>


<div id="optionsSection"><br /></div>
<h2 class="text-secondary">Customization</h2>
<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">
        Items
        <Tooltip Text="Govern how shuffled Quest Items will be placed.<br /><br />Prioritize: Quest Items will always be found in these locations.<br /><br />Include: Quest Items may be found in these locations.<br /><br />Exclude: Quest Items will never be found in these locations." Inline Multiline Placement="TooltipPlacement.Right">
            <Icon TextColor="TextColor.Secondary" Name="IconName.QuestionCircle" IconSize=IconSize.Small style="font-size: 0.600em"/> 
        </Tooltip>       
    </div> 

    <Container Class="flagBox">
        <Container Class="flagColumn">
            <EnumFlag UsePreset=usePreset Name="Logic" @bind-Value="flags.LogicOptions" Tooltip="Placement logic sets the rules that will be applied when placing items.<br /><br />Friendly: Required Items to clear a dungeon will never be placed in that dungeon to avoid the need to revisit it. Also, the Magic Mirror and the Mask will always be available before Ice Pyramid and Volcano, respectively.<br /><br />Standard: Items are randomly placed and logic merely verifies that they're all accessible." />
            <EnumFlag UsePreset=usePreset Name="Original Chests" @bind-Value="flags.ChestsShuffle" Tooltip="Original Chests are all the red chests locations in the original game, except the Venus Key Chest in Focus Tower and the new Locked Chest in Spencer's Cave, which count as NPCs.<br /><br />If a chest doesn't contain a Quest Item, it will show up as a brown box." />
            <EnumFlag UsePreset=usePreset Name="NPCs" @bind-Value="flags.NpcsShuffle" Tooltip="NPCs are all the NPC locations in the original game, as well as the new Reuben item in Mine, the Venus Key Chest in Focus Tower and the new Locked Chest in Spencer's Cave." />
            <EnumFlag UsePreset=usePreset Name="Battlefields" @bind-Value="flags.BattlefieldsShuffle" Tooltip="Battlefields are all the battlefields that gave a Quest Item in the original game; if Shuffle Battlefields Rewards is enabled, the locations will change, but the same number of battlefields will offer an item." />
            <EnumFlag UsePreset=usePreset Name="Brown Boxes" @bind-Value="flags.BoxesShuffle" Tooltip="Brown Boxes are all the boxes that contained a consumable in the original game.<br /><br />If a brown box is selected to contain a Quest Item, it will show up as a red chest." />
        </Container>
        <Container Class="flagColumn">
            <EnumFlag UsePreset=usePreset Name="Sky Coin Mode" @bind-Value="flags.SkyCoinMode" Tooltip="Configure how the Sky Coin is acquired.<br /><br />Standard: The Sky Coin will be found in a chest.<br /><br />Start With: The Sky Coin will be in your inventory at the start of the game.<br /><br />Save the Crystals: The Sky Coin will be acquired once you save all 4 crystals.<br /><br />Shattered: The Sky Coin is split in 40 fragments; you can enter Doom Castle once the required amount is found." />
            @if (flags.SkyCoinMode == SkyCoinModes.ShatteredSkyCoin)
            { 
                <EnumFlag UsePreset=usePreset Name="Sky Fragments Quantity" @bind-Value="flags.SkyCoinFragmentsQty" Tooltip="Set the number of Sky Coin Fragments required to enter Doom Castle.<br /><br />Random select one of the 3 previous options at random." />
            }
            <BoolFlag UsePreset=usePreset Name="Shuffle Brown Boxes' Content" @bind-Value="flags.ShuffleBoxesContent" Tooltip="If enabled, the content of brown boxes will be shuffled amongst themselves." />
            <BoolFlag UsePreset=usePreset Name="Random Starting Weapon" @bind-Value="flags.RandomStartingWeapon" Tooltip="Replace the usual starting weapon with the Steel Sword, the Axe, the Cat Claw or the Bomb." />
            <BoolFlag UsePreset=usePreset Name="Progressive Gear" @bind-Value="flags.ProgressiveGear" Tooltip="Pieces of gear are always acquired from weakest to strongest in a set.<br/><br/>Eg. you'll always received the Steel Sword first, then the Knight Sword and finally Excalibur, irrespective of the order the chests are opened." />
        </Container>
    </Container>
</Container>

<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">Enemies</div> 

    <Container Class="flagBox">
        <Container Class="flagColumn">
            <EnumFlag UsePreset=usePreset Name="Enemies Density" @bind-Value="flags.EnemiesDensity" Tooltip="Set how many enemies are on each maps." />
            <EnumFlag UsePreset=usePreset Name="Enemies' Stats Scaling" @bind-Value="flags.EnemiesScaling" Tooltip="Adjust enemies stats by the selected percentage." />
            <EnumFlag UsePreset=usePreset Name="Scaling Spread" @bind-Value="flags.EnemiesScalingSpread" Tooltip="Add random variation to stats scaling of enemies.<br/><br/>The percentages are additive: eg. scaling of 100% with a spread of 25% means the stats scaling will vary between 75% and 125%." />
            <EnumFlag UsePreset=usePreset Name="Enemizer Attacks" @bind-Value="flags.EnemizerAttacks" Tooltip="Shuffles enemy attacks.<br /><br />Standard: No shuffle.<br /><br />Safe Randomization: Randomize every attack but leave out self-destruct and Dark King attacks<br /><br />Chaos Randomization: Randomize and include self destruct and Dark King attacks<br /><br />Self-destruct: Every enemy self destructs<br /><br />Simple Shuffle: Instead of randomizing, shuffle one monsters attacks to another. Dark King is left vanilla." />
        </Container>
        <Container Class="flagColumn">
            <BoolFlag UsePreset=usePreset Name="Shuffle Enemies' Positions" @bind-Value="flags.ShuffleEnemiesPosition" Tooltip="Instead of their original position in a given map, enemies are randomly placed." />
        </Container>
    </Container>
</Container>

<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">Maps</div> 

    <Container Class="flagBox">
        <Container Class="flagColumn">
            <EnumFlag UsePreset=usePreset Name="Doom Castle" @bind-Value="flags.DoomCastleMode" Tooltip="Change how you reach the Dark King.<br/><br/>Standard: You need to defeat all four bosses and their floors to reach the Dark King.<br/><br/>Boss Rush: Only the bosses are blocking your way in the corridor to the Dark King's room.<br/><br/>Dark King Only: The way to the Dark King is free of any obstacle." />
            <BoolFlag UsePreset=usePreset Name="Doom Castle Shortcut" @bind-Value="flags.DoomCastleShortcut" Tooltip="Create a shortcut granting access from the start to Doom Castle at Focus Tower's entrance.<br/><br/>Also modify the Desert floor so it can be navigated without the Mega Grenades and the Dragon Claw." />
        </Container>
        <Container Class="flagColumn">
            <BoolFlag UsePreset=usePreset Name="Tweak Frustrating Dungeons" @bind-Value="flags.TweakedDungeons" Tooltip="Make some small changes to a few of the most annoying dungeons.<br/><br/>Ice Pyramid: Add 3 shortcuts on the 1st floor.<br/><br/>Giant Tree: Add shortcuts on the 1st and 4th floors and curtail mushrooms population.<br/><br/>Pazuzu's Tower: Staircases are devoid of enemies (regardless of Enemies Density settings)." />
            <BoolFlag UsePreset=usePreset Name="Overworld Shuffle" @bind-Value="flags.OverworldShuffle" Tooltip="Shuffle all Overworld Locations." />
            <BoolFlag UsePreset=usePreset Name="Dungeons Shuffle" @bind-Value="flags.FloorShuffle" Tooltip="Shuffle floors from all dungeons.<br/><br/>The 1st floor is kept the same.<br/><br/>Defeating Pazuzu won't teleport you to the 7th floor, you have to get there normally to save the Crystal and get Pazuzu's Chest." />
            <BoolFlag UsePreset=usePreset Name="Crests Shuffle" @bind-Value="flags.CrestShuffle" Tooltip="Shuffle the Crests' tiles between themselves." />        
        </Container>
    </Container>
</Container>

<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">Other</div> 

    <Container Class="flagBox">
        <Container Class="flagColumn">
            <EnumFlag UsePreset=usePreset Name="Leveling Curve" @bind-Value="flags.LevelingCurve" Tooltip="Adjust the quantity of XP needed to gain levels.<br/><br/>A curve of 2x means that leveling will be twice faster." />
            <BoolFlag UsePreset=usePreset Name="Generate Spoilers File" @bind-Value="flags.EnableSpoilers" Tooltip="Generate a .txt file with each Key Item's locations." />
        </Container>
        <Container Class="flagColumn">
            <BoolFlag UsePreset=usePreset Name="Shuffle Battlefields Rewards" @bind-Value="flags.ShuffleBattlefieldRewards" Tooltip="Shuffle the type of reward (Item, XP, GP) given by battlefields and color code them by reward type.<br/><br/>Blue: Give an item.<br/><br/>Grey: Give XP.<br/><br/>Green: Give GP." />
            <EnumFlag UsePreset=usePreset Name="Battlefields Battles Quantity" @bind-Value="flags.BattlesQuantity" Tooltip="Adjust the number of battles that need to be fought to get a battlefield's reward." />
        </Container>
    </Container>
</Container>

<div><br /></div>

<Container class="sectionBox">
    <div class="box-title text-secondary">Preferences</div> 
    <div class="text-secondary">Preferences doesn't affect the randomization and can be enabled/disabled without any impact on gameplay.</div>
    <Container Class="flagBox">
        <Container Class="flagColumn">
            <BoolFlag UsePreset=false Name="Randomize Benjamin's Palette" @bind-Value="preferences.RandomBenjaminPalette" Tooltip="Randomly select Benjamin's palette, giving him a brand new look!" />
            <BoolFlag UsePreset=false Name="Randomize Music" @bind-Value="preferences.RandomMusic" Tooltip="Shuffle the music tracks." />
            <Field class="text-secondary dropFlag romBtn">
                <Button Color="Color.Primary" Clicked="@SavePreferences">Save Preferences</Button>
            </Field>
        </Container>
        <Container Class="flagColumn">
        </Container>
    </Container>
</Container>

<div id="infoSection"><br /></div>

<Information />

<div><br /><br /><br /><br /><br /></div>

@code{
    //bool IntroPaneVisible = true;
    //bool FilePaneVisible = false;
    //bool MainPaneVisible = false;
    //bool ExtPaneVisible = false;

    private FFMQRom newRom = new();
    private long maxFileSize = 0x80200;
    private bool isLoadingRom = false;
    private bool isGenerating = false;
    private bool romLoaded = false;
    private bool usePreset = false;
    private int titleHeight = 80;
    private bool sandboxMode = false;
    private bool betaStatus = false;

    private Blob seed = new byte[4];
    private string showSeed;
    private Flags flags = new();
    private Preferences preferences = new();
    private bool generatedRom = false;
    private string seedMessage = "";
    private string romMessage = "";
    private string flagsMessage = "";
    private List<string> titleLetters = new List<string> { "logo/mqlogoM.png", "logo/mqlogoy.png", "logo/mqlogos.png", "logo/mqlogot.png", "logo/mqlogoi.png", "logo/mqlogoc.png", "logo/mqlogoQ.png", "logo/mqlogou.png", "logo/mqlogoe.png", "logo/mqlogos2.png", "logo/mqlogot2.png" };
    private bool updateFlagString = true;
    private string tempFlagString;

    private string yamlPreset = "";
    private string yamlMessage = "";
    private string yamlName = "default";

    [Parameter]
    public string flagString
    {
        get
        {
            if (updateFlagString)
            {
                tempFlagString = flags.GenerateFlagString();                
                UpdateUrl();
            }
            return tempFlagString;
        }
        set
        {
            if (updateFlagString)
            {
                SetFlags(value);
                UpdateUrl();
            }
        }
    }

    private bool GetBetaStatus()
    {
        var uri = new Uri(NavigationManager.Uri);

        string fullUrl = uri.OriginalString;
        int index = fullUrl.IndexOf("dev");
        if (index >= 0)
        {
            return true;
        }

        return false;
    }

    private bool GetSandboxStatus()
    {
        var uri = new Uri(NavigationManager.Uri);

        string fullUrl = uri.OriginalString;
        int index = fullUrl.IndexOf("sandbox");
        if (index >= 0)
        {

            return true;
        }    

        return false;
    }

    private async Task OnGenerate()
    {
        isGenerating = true;
        StateHasChanged();
        await Task.Delay(1);
        await Generate();
        isGenerating = false;
    }

    private async Task Generate()
    {
        if (newRom.IsEmpty())
        {
            romMessage = "No file.";
            return;
        }

        if (generatedRom)
        {
            newRom.RestoreOriginalData();
            generatedRom = false;
        }

        if (!newRom.Validate())
        {
            romMessage = "Invalid ROM file.";
            return;
        }

        if (GetBetaStatus())
        {
            newRom.beta = true;
        }

        try
        {
            newRom.Randomize(seed, flags, preferences);

            romMessage = "ROM file generated successfully.";

            var fs = newRom.DataStream();
            var fileName = "FFMQR_" + FFMQLib.Metadata.Version + "_" + seed.ToHex() + "_" + flags.GenerateFlagString() + ".sfc";

            using var streamRef = new DotNetStreamReference(stream: fs);

            await JS.InvokeVoidAsync("downloadFileFromStream", fileName, streamRef);

            if (flags.EnableSpoilers)
            {
                var fsSpoilers = newRom.SpoilerStream();
                var fileNameSpoilers = "FFMQR_Spoilers_" + FFMQLib.Metadata.Version + "_" + seed.ToHex() + "_" + flags.GenerateFlagString() + ".txt";

                using var streamRefSpoilers = new DotNetStreamReference(stream: fsSpoilers);

                await JS.InvokeVoidAsync("downloadFileFromStream", fileNameSpoilers, streamRefSpoilers);
            }
        }
        catch (Exception ex)
        {
            romMessage = ex.Message;
            #if DEBUG
                await ErrorDump(ex.Message);
            #endif
        }
    
        generatedRom = true;
    }

    private async Task ErrorDump(string dump)
    {
        var errorDump = new MemoryStream(Encoding.UTF8.GetBytes(romMessage));
        var fileNameSpoilers = "FFMQR_Error_" + FFMQLib.Metadata.Version + "_" + seed.ToHex() + "_" + flags.GenerateFlagString() + ".txt";

        using var streamRefSpoilers = new DotNetStreamReference(stream: errorDump);

        await JS.InvokeVoidAsync("downloadFileFromStream", fileNameSpoilers, streamRefSpoilers);        
    }


    private async Task LoadFiles(FileChangedEventArgs e)
    {
        romMessage = "Loading...";
        isLoadingRom = true;
        StateHasChanged();
        try
        {
            await newRom.LoadAsync(e.Files.First().OpenReadStream(maxFileSize));
            if (!newRom.Validate())
            {
                romMessage = "Invalid ROM file.";
                isLoadingRom = false;
                return;
            }
            else
            {
                romMessage = "ROM file loaded succesfully.";
                isLoadingRom = false;
                romLoaded = true;
                newRom.BackupOriginalData();
                SavePreferences();
            }
        }
        catch (Exception ex)
        {
            Console.WriteLine(ex.Message);
        }
    }

    private void UnloadRom()
    {
        romLoaded = false;
        preferences.RomPath = "";
        romMessage = "";
        newRom = new();
        SavePreferences();
    }

    private async Task LoadYamlFromUpload(FileChangedEventArgs e)
    {
        try
        {
            using (StreamReader streamReader = new StreamReader(e.Files.First().OpenReadStream(maxFileSize), Encoding.UTF8))
            {
                await LoadYamlFromStreamReader(streamReader);
            }
        }
        catch (Exception ex)
        {
            yamlMessage = ex.Message;
            Console.WriteLine(ex.Message);
        }
    }

    private async Task LoadYamlFromFile(string presetname)
    {
        try
        {
            var stream = await Http.GetStreamAsync("presets/" + presetname + ".yaml");

            using (StreamReader streamReader = new StreamReader(stream, Encoding.UTF8))
            {
                await LoadYamlFromStreamReader(streamReader);
            }
        }
        catch (Exception ex)
        {
            yamlMessage = ex.Message;
            Console.WriteLine(ex.Message);
        }
    }

    private async Task LoadYamlFromStreamReader(StreamReader streamReader)
    {
        try
        {
            using (streamReader)
            {
                yamlPreset = await streamReader.ReadToEndAsync();
            }

            yamlName = flags.ReadYaml(yamlPreset, seed);
            flagsMessage = "Preset loaded succesfully.";
        }
        catch (Exception ex)
        {
            yamlMessage = ex.Message;
            Console.WriteLine(ex.Message);
        }
    }

    private async void OnExportYaml(string yamlname)
    {
        var yamlStream = flags.YamlStream(yamlname);
        var filenameYaml = yamlname + ".yaml";
        using var streamRefSpoilers = new DotNetStreamReference(stream: yamlStream);
        {
            await JS.InvokeVoidAsync("downloadFileFromStream", filenameYaml, streamRefSpoilers);
        }
    }

    private async void OnPresetAction((StreamReader name, bool usepreset, bool loadfromfile) action)
    {
        if (!action.usepreset && !action.loadfromfile)
        {
            usePreset = false;
            StateHasChanged();
        }
        else 
        {
            await LoadYamlFromStreamReader(action.name);
            usePreset = action.usepreset;
            StateHasChanged();
        }
    }


    private void RollSeed()
    {
        var rng = new Random();
        rng.NextBytes(seed);
        MT19337 rng2 = new MT19337((uint)seed.ToUInts().Sum(x => x));
        titleLetters.Shuffle(rng2);
        showSeed = seed.ToHex();

        if (usePreset)
        {
            flags.ReadYaml(yamlPreset, seed);
        }

        UpdateUrl();
    }

    private void UpdateUrl()
    { 
        var uri = new Uri(NavigationManager.Uri);

        var test = NavigationManager.GetUriWithQueryParameters(new Dictionary<string, object>
        {
         { "s", showSeed },
         { "f", flags.GenerateFlagString() }
        });

        NavigationManager.NavigateTo(test);
    }

    private string MakeParsableUriString(string uristring)
    {
        var qmarkIndex = uristring.IndexOf('?');
        var hashIndex = uristring.IndexOf('#');

        if (qmarkIndex == -1)
        {
            return ""; 
        }
        else if (qmarkIndex > hashIndex)
        {
            return uristring.Remove(0, qmarkIndex);
        }
        else
        { 
            return uristring.Remove(hashIndex).Remove(0, qmarkIndex);
        }
    }

    protected override async void OnInitialized()
    {
        sandboxMode = GetSandboxStatus();
        betaStatus = GetBetaStatus();
        if (sandboxMode)
        {
            titleHeight = 240;
        }

        var uri = new Uri(NavigationManager.Uri);

        string parsableUri = MakeParsableUriString(uri.OriginalString);

        var seedParameter = HttpUtility.ParseQueryString(parsableUri).Get("s");
        if (seedParameter != null)
        {
            SetSeed(seedParameter);
        }
        else
        {
            RollSeed();            
        }

        var flagsParameter = HttpUtility.ParseQueryString(parsableUri).Get("f");
        if (flagsParameter != null)
        {
            flagString = flagsParameter;
        }
        else
        {
            await LoadYamlFromFile("sgl2022");
            StateHasChanged();
            flagsMessage = "Using default flags (SGL2022).";
        }

        LoadPreferences();
    }

    public void SavePreferences()
    {
        if (!newRom.IsEmpty())
        {
            newRom.RestoreOriginalData();
            preferences.RomPath = Convert.ToBase64String(newRom.DataReadOnly);
        }
        else
        {
            preferences.RomPath = "";
        }

        var prefList = preferences.GetType().GetProperties().ToList();

        foreach(var pref in prefList)
        {
            localStorage.SetItem(pref.Name, pref.GetValue(preferences, null));
        }
    }

    public void LoadPreferences()
    {
        var prefList = preferences.GetType().GetProperties().ToList();

        foreach(var pref in prefList)
        {
            if(pref.PropertyType == typeof(bool))
            {
                pref.SetValue(preferences, localStorage.GetItem<bool>(pref.Name));
            }
            else if(pref.PropertyType == typeof(string))
            { 
                string pathvalue = localStorage.GetItem<string>(pref.Name);

                pref.SetValue(preferences, pathvalue ?? "");
            }
        }

        if (preferences.RomPath != "")
        {
            newRom.Load(Convert.FromBase64String(preferences.RomPath));
            romMessage = "Loading...";
            isLoadingRom = true;
            StateHasChanged();

            try
            {
                if (!newRom.Validate())
                {
                    romMessage = "Invalid ROM file.";
                    isLoadingRom = false;
                    romLoaded = false;
                    return;
                }
                else
                {
                    romMessage = "ROM file loaded from memory succesfully.";
                    isLoadingRom = false;
                    romLoaded = true;
                    newRom.BackupOriginalData();
                    StateHasChanged();
                }
            }
            catch (Exception ex)
            {
                Console.WriteLine(ex.Message);
            }
        }
    }

    // Seed Field Functions
    Task SeedOnChanged(string value)
    {
        showSeed = value;
        EvaluateSeed(showSeed);
        return Task.CompletedTask;
    }

    Task SeedOnKeyUp(KeyboardEventArgs value)
    {
        if (value.Key == "Enter")
        {
            EvaluateSeed(showSeed);
            SetSeed(showSeed);
            UpdateUrl();
        }

        return Task.CompletedTask;
    }

    Task SeedOnLoseFocus()
    {
        EvaluateSeed(showSeed);
        SetSeed(showSeed);
        UpdateUrl();
        return Task.CompletedTask;
    }

    private void EvaluateSeed(string value)
    {
        if (value.Length < 8)
        {
            seedMessage = "Invalid Seed: Seed string is too short (min 8 digits).";
        }
        else if (value.Length > 8)
        {
            seedMessage = "Invalid Seed: Seed string is too long (max 8 digits).";
        }
        else
        {
            seedMessage = "";
        }
    }

    private void SetSeed(string value)
    {
        showSeed = value;
        try
        {
            if (showSeed.Length > 8)
            { 
                showSeed = showSeed.Remove(8);
            }
            showSeed = showSeed.PadLeft(8, '0');
            seed = Blob.FromHex(showSeed);
            seedMessage = "";
        }
        catch (Exception ex)
        {
            seedMessage = "Invalid Seed: " + ex.Message;
        }
    }



    private async Task CopyTextToClipboard()
    {
        await JS.InvokeVoidAsync("copyClipboard");
    }

    // Flag Field Functions
    Task FlagsOnChanged( string value )
    {
        updateFlagString = false;
        tempFlagString = value;
        return Task.CompletedTask;
    }

    Task FlagsOnKeyUp(KeyboardEventArgs value)
    {
        if (value.Key == "Enter")
        {
            updateFlagString = true;
            flagString = tempFlagString;
            UpdateUrl();
        }

        return Task.CompletedTask;
    }

    Task FlagsOnLoseFocus()
    {
        updateFlagString = true;
        flagString = tempFlagString;
        UpdateUrl();
        return Task.CompletedTask;
    }

    Task SetFlags( string value )
    {
        try
        {
            flags.ReadFlagString(value);
            flagsMessage = "Flags loaded successfully.";
        }
        catch (Exception)
        {
            flagsMessage = "Invalid flags string.";
        }

        return Task.CompletedTask;
    }
}
